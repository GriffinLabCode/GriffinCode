function [clustTT, was_scaled] = ExtractCluster(TT, clusterIndex)% MClust/ExtractCluster%% INPUTS%    TT -- TT tsd%    clusterIndex - output of FindInCluster%  % OUTPUTS%    clustTT -- TT tsd containing only those points in cluster%    returns a non-zero value of only a subset of the available points were retrieved.%     the value is the number of points in the REAL CLUSTER, not the scaled cluster. The %     number in the scaled cluster can be gathered by just counting the rows clustTT.%% ADR 1999% Version M1.0% RELEASED as part of MClust 2.0% See standard disclaimer in Contents.m%% cowen 2001%  Major modification:  If TT is empty, lookup the waveforms in the original TTfile.%    this necessitated importing the global TTFileName variable.% cowen 2001%  If the TT data from a cluster is to be loaded into memory, and the cluster has over%  100,000 points, subsample the data (random subsample without replacement). This allows %  for the display of data that cannot fit into available memory. The smart way would be to %  scale the size dependent on free memory-- Smart is hard so I am not going to do it.%% %% Status: PROMOTED (Release version) % See documentation for copyright (owned by original authors) and warranties (none!).% This code released as part of MClust 3.0.% Version control M3.0.global MClust_TTfn MClust_TTdn MClust_TTextglobal MClust_TTDataglobal MClust_FeatureTimestamps MClust_max_records_to_loadwas_scaled = 0; % = amount of points in cluster IF the cluster was larger than n_to_load.if isempty(MClust_max_records_to_load)	threshold_spikes = 50000; % Number of spikes that signals subsampling	n_to_load = 50000; % Number of spikes to loadelse	threshold_spikes = MClust_max_records_to_load;	n_to_load = MClust_max_records_to_load;endTTfn = fullfile(MClust_TTdn, [MClust_TTfn MClust_TText]);if isempty(MClust_TTData)    if ~isempty(MClust_FeatureTimestamps)        n_in_cluster = length(clusterIndex);        if n_in_cluster < threshold_spikes            pushdir(MClust_TTdn);            [t,wv] = MClust_LoadNeuralData(TTfn, clusterIndex,2);            popdir;            % ncst            % check to see if the timestamps you get out match those you put in            if ~isempty(t) && any(t~=MClust_FeatureTimestamps(clusterIndex)) %% Changed to sum to any -- JCJ July 2007                if (length(t)==length(MClust_FeatureTimestamps(clusterIndex)))...                        && any(abs(t-MClust_FeatureTimestamps(clusterIndex))>sqrt(eps)) %% Changed to ignore precision differences between 32 and 64bit systems -- JCJ Oct 2007                    disp(' ')                    disp(['Error: Timestamp mismatch in ' MClust_TTfn])                    GoodPoints = t~=MClust_FeatureTimestamps(clusterIndex);                    t = t(GoodPoints == 0);                    wv = wv(GoodPoints == 0,:,:);                    disp(['Removed ' num2str(length(find(GoodPoints ~= 0))) ' of ' num2str(length(t)) ' points'])                    disp(' ')                else                    warning('MClust:Warning','Timestamp precision differences detected! Consider recalculating feature data files with the same loading engine currently in use')                end            end            disp(['Loaded ' num2str(length(t)) ' spikes.'])        else            disp([num2str(n_in_cluster) ' spikes in cluster, loading a subset of ' num2str(n_to_load) ' spikes.'])            % Randomize the indices to ensure a random subsample.            clusterIndex = clusterIndex(randperm(n_in_cluster));            % Choose a random subsample.             pushdir(MClust_TTdn);            [t,wv] = MClust_LoadNeuralData(TTfn, sort(clusterIndex(1:n_to_load)),2);            popdir;            was_scaled = n_in_cluster;             % ncst            % check to see if the timestamps you get out match those you put in            if any(t~=MClust_FeatureTimestamps(sort(clusterIndex(1:n_to_load)))) %% Changed to sum to any -- JCJ July 2006                if (length(t)==length(MClust_FeatureTimestamps(clusterIndex)))...                        && any(abs(t-MClust_FeatureTimestamps(clusterIndex))>sqrt(eps)) %% Changed to ignore precision differences between 32 and 64bit systems -- JCJ Oct 2007                    disp(' ')                    disp(['Error: Timestamp mismatch in ' MClust_TTfn])                    GoodPoints = t~=MClust_FeatureTimestamps(sort(clusterIndex(1:n_to_load)));                    numPoints = length(t);                    t = t(GoodPoints == 0);                    wv = wv(GoodPoints == 0,:,:);                    disp(['Removed ' num2str(length(find(GoodPoints ~= 0))) ' of ' num2str(numPoints) ' points'])                    disp(' ')                else                    warning('MClust:Warning','Timestamp precision differences detected! Consider recalculating feature data files with the same loading engine currently in use')                end            end        end        clustTT = tsd(t,wv,'ts');    else        msgbox('No spikes in this cluster')    endelse    TTtimestamps = Range(TT, 'ts');    TTdata = Data(TT);    clustTT = tsd(TTtimestamps(clusterIndex), TTdata(clusterIndex,:,:));end