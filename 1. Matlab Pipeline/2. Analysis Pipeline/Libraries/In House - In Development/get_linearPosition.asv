%% get_linearPosition
% this function takes position data and actual maze measurements (not
% including startbox).
% example inputs:
% 
% -- INPUTS -- %
% datafolder: directory of data
% int_name: name of int file
% vt_name: video track file name
% missing_data: can be 'exclude', 'ignore', or 'interp'
% measurements: a structure array of measurements. Includes stem, goal arm,
% g
%{
    datafolder   = 'X:\01.Experiments\John n Andrew\Dual optogenetics w mPFC recordings\All Subjects - DNMP\Good performance\Medial Prefrontal Cortex\Baby Groot 9-11-18'; 
    int_name     = 'Int_file.mat';
    vt_name      = 'VT1.mat';
    missing_data = 'exclude';
    measurements.stem     = 137;
    measurements.goalArm  = 50;
    measurements.goalZone = 37;
    measurements.retArm   = 130;
%}

function [data] = get_linearPosition(datafolder,int_name,vt_name,missing_data)

% addpaths
%Startup_linearSkeleton

% get vt data
[ExtractedX,ExtractedY,TimeStamps] = getVTdata(datafolder,missing_data,vt_name,measurements);

% conversion shouldn't be necessary if you provide the actual maze
% dimensions. This is bc linearizing is binning and we can restrict the
% number of bins.
%{
% define the convFact variable
data.measurements.convFact(1:2) = [2.09 2.04]; % left room is easy. its almost a perfect square. first col is x, second y

% convert x and y data
ExtractedX = ExtractedX./data.measurements.convFact(1);
ExtractedY = ExtractedY./data.measurements.convFact(2);
%}

% load int file
load(int_name)

% what is the measured distance from stem entry to startbox entry?
data.measurements.stem     = measurements.stem;
data.measurements.goalArm  = measurements.goalArm;
data.measurements.goalZone = measurements.goalZone;
data.measurements.retArm   = measurements.retArm;
data.measurements.total_distance = data.measurements.stem+data.measurements.goalArm...
    +data.measurements.goalZone+data.measurements.retArm;

% position data
data.pos(1,:) = ExtractedX;
data.pos(2,:) = ExtractedY;

% get linear skeleton
data.idealTraj = idealized_trajectory_2(data.pos,data.measurements.total_distance);

%% separate left and right trajectories

% separate left/right trials
Int_left  = Int(Int(:,3)==1,:);
Int_right = Int(Int(:,3)==0,:);

% get left trajectory position
for triali = 1:size(Int_left,1)
    data.X_left{triali} = ExtractedX(TimeStamps >= Int_left(triali,1) & TimeStamps <= Int_left(triali,8));
    data.Y_left{triali} = ExtractedY(TimeStamps >= Int_left(triali,1) & TimeStamps <= Int_left(triali,8));
end

% get right trajectory position
for triali = 1:size(Int_right,1)
    data.X_right{triali} = ExtractedX(TimeStamps >= Int_right(triali,1) & TimeStamps <= Int_right(triali,8));
    data.Y_right{triali} = ExtractedY(TimeStamps >= Int_right(triali,1) & TimeStamps <= Int_right(triali,8));
end

%% linearize position

% left linear position
numTrials = length(data.X_left);
for i = 1:numTrials
    
    % get coordinate points between ideal trajectory and real data
    data.linearPosition.left{i} = griddata(data.idealTraj.idealL(1,:),data.idealTraj.idealL(2,:),1:length(data.idealTraj.idealL(1,:)),data.X_left{i},data.Y_left{i},'nearest');

end

% right linear position
numTrials = length(data.X_right);
for i = 1:numTrials
    
    % get coordinate points between ideal trajectory and real data
    data.linearPosition.right{i} = griddata(data.idealTraj.idealR(1,:),data.idealTraj.idealR(2,:),1:length(data.idealTraj.idealR(1,:)),data.X_right{i},data.Y_right{i},'nearest');

end

%{
% save this somewhere, include idealTraj and convFact
prompt     = 'Enter a directory to save trajectory skeleton: ';
dir_save   = input(prompt,'s');
cd(dir_save);
save('trajectory_skeleton.mat','idealTraj','convFact');

% remove paths to avoid function conflicts
%rmPaths_linearSkeleton
%}

end