// Created 1/8/01 Steve Franks
// This file 'works' with no modification under MS Visual C++ 6.0

// avoid duplicate definitions
#ifndef _NLX_DATATYPE_H
#define _NLX_DATATYPE_H


//in GCC, byte packing is done with the __packed__attribute and not with the construct below

//This forces all records to be byte-packed for most efficient use of disk space & lack of confusion
//#pragma pack(push, before_nlx_datatypes)
//#pragma pack(1)

#include "compatibility.h"

#ifndef Nlx_Odl
	#define Nlx_Odl
#endif

const int DATAFILETYPE_INVALID = -1;
const int DATAFILETYPE_RESERVED = 0;
const int DATAFILETYPE_SESPIKE = 1;
const int DATAFILETYPE_STSPIKE = 2;
const int DATAFILETYPE_TIMESTAMP = 3;
const int DATAFILETYPE_TTSPIKE = 4;
const int DATAFILETYPE_CSC = 5;
const int DATAFILETYPE_EVENT = 6;
const int DATAFILETYPE_VIDEO = 7;

//////////////////
// Spike Datatypes
//////////////////

const int TT_NUMELECTRODES = 4;
const int ST_NUMELECTRODES = 2; 
const int SE_NUMELECTRODES = 1; 
const int MAX_PARAMS = 8;
const int SPIKE_NUMPOINTS = 32;

//IMPORTANT!  If you are getting a compile error on Nlx_Odl, you just need to add the line:
//IMPORTANT!																				#define Nlx_Odl
//IMPORTANT!		right before you '#include' this file.  This will make Nlx_Odl
//IMPORTANT!		equate out to nothing in your compiler, which will fix the error.
//IMPORTANT!		(Nlx_Odl is used internally by Neuralynx to generate additional compile information.)

// used only as a part of larger record
Nlx_Odl struct TetPoint {
	signed __int16		snADVal[TT_NUMELECTRODES];
};

// used only as a part of larger record
Nlx_Odl struct StereoPoint {
	signed __int16		snADVal[ST_NUMELECTRODES];
};

// used only as a part of larger record
Nlx_Odl struct SinglePoint {
	signed __int16		snADVal[SE_NUMELECTRODES];
};


// a tetrode (TTScAcqEnt record)
Nlx_Odl struct TTRec	{
		unsigned __int64	qwTimeStamp;			// TS
		unsigned __int32	dwScNumber;			// Channel number
		unsigned __int32	dwCellNumber;			// What cell was this calculated to be? filled in by online cluster analysis
		signed __int32		dnParams[MAX_PARAMS];		// Parameters calculated from snData by the clustering algoritm
		TetPoint		snData[SPIKE_NUMPOINTS];	// The A-D data samples

} __attribute__((__packed__));

// a stereotrode
Nlx_Odl struct STRec	{
		unsigned __int64	qwTimeStamp;				// See TTRec, above
		unsigned __int32	dwScNumber;
		unsigned __int32	dwCellNumber;
		signed __int32		dnParams[MAX_PARAMS];
		StereoPoint		snData[SPIKE_NUMPOINTS];
} __attribute__((__packed__));

// a single electrode
Nlx_Odl struct SERec	{
		unsigned __int64	qwTimeStamp;				// See TTRec, above
		unsigned __int32	dwScNumber;
		unsigned __int32	dwCellNumber;
		signed __int32		dnParams[MAX_PARAMS];
		SinglePoint		snData[SPIKE_NUMPOINTS];
} __attribute__((__packed__));

//This is totally generic for passing around the appropriate information in function calls
//May be either a TT, ST, or SE rec.  //Waveforms can be acessed as (short*)(&(*SCRec[1]))
Nlx_Odl struct SCRec	{
		unsigned __int64	qwTimeStamp;
		unsigned __int32	dwScNumber;
		unsigned __int32	dwCellNumber;
		signed __int32	 dnParams[MAX_PARAMS];
} __attribute__((__packed__));


Nlx_Odl struct SCMin {
		unsigned __int64	qwTimeStamp;
		unsigned __int32	dwCellNumber;		
} __attribute__((__packed__));
////////////////////////////////
// Continuous Sampling Datatypes
////////////////////////////////

const int MAX_CSC_SAMPLES = 512;

// a CSCAcqEnt record for EEG data
Nlx_Odl struct CRRec	{
		unsigned __int64	qwTimeStamp;			// TS
		unsigned __int32	dwChannelNum;			// Channel number
		unsigned __int32	dwSampleFreq;			// freq in hertz of sampling rate
		unsigned __int32	dwNumValidSamples;		// number of snSamples containing useful data
		signed __int16	 snSamples[MAX_CSC_SAMPLES];		// the A-D data samples
} __attribute__((__packed__));


//////////////////
// Event Datatypes
//////////////////

const int EVENT_NUM_EXTRAS = 8;
const int NLX_EventRecStringSize = 128;

//just don't use a zero for ambiguity's sake
const int RESERVED_EVENTID = 0;
//the first Dt3010 hardware (Cheetah-32 / "Cheetah Digital Box"))
const int DT3010_BOARD1_EVENTID = 1;
//the second Dt3010 hw (Cheetah-64 / "Cheetah Digital Box")
const int DT3010_BOARD2_EVENTID = 2;
//the DcDcb Hardware (Cheeta-160 / "Cheetah Interface Box")
const int DCDCB_EVENTID = 0x77;
//the Cube Hardware
const int CUBE_EVENTID = 0x69;
// any event generated by the user at the keyboard gets this id.
const int KEYBOARD_EVENTID = 4;
//any event from a configfile or experiment control program gets this by default 
//(though you can override it and pick your own - see -PostEvent command).
const int CONFIGFILE_DEFAULT_EVENTID = 5;
//any event generated by the video zone utility
const int VIDEOEVENTGEN_EVENTID = 6;
// following two values are rec id's for the start of a DT3010 DAC output start
const int DT3010_BOARD1_DAC_OUTPUT_STARTED = 7;  // ttl value will be the wave buffer #
const int DT3010_BOARD2_DAC_OUTPUT_STARTED = 8;  // ttl value will be the wave buffer #
const int DT3010_BOARD1_ADC_ACQ_STARTED = 12;     // a/d #1 started
const int DT3010_BOARD2_ADC_ACQ_STARTED = 14;     // a/d #1 started

//event generated by add-on digital input utility
const int ADDONDIGITALINPUT_EVENTID = 17;
const int OPTIONAL_DIGITALINPUT_EVENTID = 10;



// record for EventAcqEnt objects
Nlx_Odl struct EventRec	{
  short   	nstx;             			// always 800 from DCDCB
  short   	npkt_id;          			// DCDCB ID  1002, etc.
  short   	npkt_data_size;   			// always 2
  __int64	qwTimeStamp;
  short   	nevent_id;       			// just an id value
  short   	nttl;            			// TTL input value
  short   	ncrc;            			// from the DCDCB
  short   	ndummy1;          			// just a place holder
  short   	ndummy2;          			// just a place holder
  __int32	dnExtra[EVENT_NUM_EXTRAS];       			// extra "bit values"
  char		EventString[NLX_EventRecStringSize]; 	// char string for user input events
} __attribute__((__packed__));


//////////////////////////
// Video Tracker Datatypes
//////////////////////////

const int NLX_VTREC_NUM_POINTS = 400;
const int NLX_VTREC_NUM_TARGETS = 50;

// record for TrackerAcqEnt objects
Nlx_Odl struct VideoRec	{
  unsigned __int16	swstx;					// should be 800 as from the DCDCB
  unsigned __int16	swid;					// should be 0x1000 or 0x1001 as from the DCDCB
  unsigned __int16	swdata_size;				// should be 800 as from the DCDCB
  unsigned __int64	qwTimeStamp;				// TS
  unsigned __int32	dwPoints[NLX_VTREC_NUM_POINTS];		// the points with color bit values x&y - note: this is a bit field!
  signed __int16	sncrc;					// as from the dcdcb
  signed __int32	dnextracted_x;				// from our extraction algorithm
  signed __int32	dnextracted_y;				// from our extraction algorithm
  signed __int32	dnextracted_angle;			// unimplemeted - equal to (5 * numtargets) in version 2.02
  signed __int32	dntargets[NLX_VTREC_NUM_TARGETS];	// colored targets with same format as the points
} __attribute__((__packed__));

// __packed__ is important here to have no padding zeros


// bit masks for isolating data from bitfields contained in 'dwPoints' and 'dntargets'

const unsigned int VREC_COLOR_MASK = 0x7000F000;  	// logical OR of all the colors
const unsigned int VREC_LU_MASK = 0x8000;		// luminance mask
const unsigned int VREC_RR_MASK = 0x4000;		// pure & raw RGB masks
const unsigned int VREC_RG_MASK = 0x2000;
const unsigned int VREC_RB_MASK = 0x1000;
const unsigned int VREC_PR_MASK = 0x40000000;
const unsigned int VREC_PG_MASK = 0x20000000;
const unsigned int VREC_PB_MASK = 0x10000000;
const unsigned int VREC_RS_MASK = 0x80000000;		// reserved bit mask
const unsigned int VREC_X_MASK = 0x00000FFF;		// x value mask
const unsigned int VREC_Y_MASK = 0x0FFF0000;		// y val


//#pragma pack(pop, before_nlx_datatypes) // back to old packing scheme

#endif  //_NLX_DATATYPE_H

//////
// EOF
//////
