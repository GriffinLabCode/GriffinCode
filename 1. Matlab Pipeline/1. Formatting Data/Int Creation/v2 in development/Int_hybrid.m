%% Int_v2
% I wrote this code to replace the existing method for creation of the Int
% file. This is for two reasons:
%   1) In rare circumstances, particularly after we moved to new rooms, we
%   began experiencing duplication errors in the old Int creation method. 
%   2) Importantly, the old Int file was not intuitive, and the code that
%   created it was also not intuitive. The code here is designed with
%   comments to facilitate the learning of its creation for better
%   troubleshooting. Moreover, there are two Int file outputs here, the
%   first is the old Int file which most of our existing code works with.
%   But the second is a newer int file in the form of a table that clearly
%   specifies which column corresponds to which maze location. 
%
% NOTE: This only works with T-maze tasks
%
% -- INPUTS -- %
% datafolder: the directory housing your data
%
% missing_data: How to handle tracking errors. Do 'exclude'.
%
% vt_name: video tracking data name, should be 'VT1.mat'
%
% taskType: the type of T-maze task you are using. For example, you could
%           enter 'DA' or 'DNMP'. 
%               ****** IMPORTANT ******
%               if running CA and there is no startbox, then type 'CA'.
%               However, if you are running CA with a startbox, enter 'DA'
%
% Int_information: This is a file that is generated by running
%                   'view_VT_data'. This file contains maze parameters,
%                   like where the startbox, stem, and choice point are
% 
% -- OUTPUTS -- %
% Int_old: the old formatted file. Each element is a time-stamp recorded
%           from the video camera, and each pixel was assigned a time-stamp
%           by cheetah. Therefore, the timestamps are arbitrary to cheetah
%           time of your machine
%               col1: stem entry
%               col5: cp entry
%               col6: cp exit (goal arm entry)
%               col2: goal zone entry (goal arm exit)
%               col7: goal zone exit (return arm entry)
%               col8: startbox entry (return arm exit)
%               col3: trajectory, 0 is left, 1 is right. May need to check
%                      this as sometimes cameras flip the maze orientation
%               col4: choice accuracy, 0 is correct, 1 is incorrect
%
% Int_new: a table formatted with columns that tell you what each timestamp
%           corresponds to.
%
% written by John Stout with extreme help from the old Int method
clear; clc;
datafolder   = 'X:\01.Experiments\R21\21-12\Sessions\DA Habituation\2021-11-11_12-01-46';
intParamsLoc = 'X:\01.Experiments\R21\Int Location Parameters';
%cd(intParamsLoc);
%load('Int_parameters')
missing_data = 'interp';
vt_name = 'VT1.mat';
taskType = 'DA';

% load int file
cd(datafolder);
load('Int_IR')

%% pull in video tracking data
% meat
[x,y,t] = getVTdata(datafolder,missing_data,vt_name);

% number of position samples
numSamples = length(t);

%% define rectangles for all coordinates
load('Int_information')

% stem
xv_stem = [STM_fld(1)+STM_fld(3) STM_fld(1) STM_fld(1) STM_fld(1)+STM_fld(3) STM_fld(1)+STM_fld(3)];
yv_stem = [STM_fld(2) STM_fld(2) STM_fld(2)+STM_fld(4) STM_fld(2)+STM_fld(4) STM_fld(2)];

% choice point
xv_cp = [CP_fld(1)+CP_fld(3) CP_fld(1) CP_fld(1) CP_fld(1)+CP_fld(3) CP_fld(1)+CP_fld(3)];
yv_cp = [CP_fld(2) CP_fld(2) CP_fld(2)+CP_fld(4) CP_fld(2)+CP_fld(4) CP_fld(2)];

% left reward field
xv_lr = [lRW_fld(1)+lRW_fld(3) lRW_fld(1) lRW_fld(1) lRW_fld(1)+lRW_fld(3) lRW_fld(1)+lRW_fld(3)];
yv_lr = [lRW_fld(2) lRW_fld(2) lRW_fld(2)+lRW_fld(4) lRW_fld(2)+lRW_fld(4) lRW_fld(2)];

% right reward field
xv_rr = [rRW_fld(1)+rRW_fld(3) rRW_fld(1) rRW_fld(1) rRW_fld(1)+rRW_fld(3) rRW_fld(1)+rRW_fld(3)];
yv_rr = [rRW_fld(2) rRW_fld(2) rRW_fld(2)+rRW_fld(4) rRW_fld(2)+rRW_fld(4) lRW_fld(2)];

% startbox
xv_sb = [PED_fld(1)+PED_fld(3) PED_fld(1) PED_fld(1) PED_fld(1)+PED_fld(3) PED_fld(1)+PED_fld(3)];
yv_sb = [PED_fld(2) PED_fld(2) PED_fld(2)+PED_fld(4) PED_fld(2)+PED_fld(4) lRW_fld(2)];

%% identify where each sample in the position data belongs to

% stem 
[in_stem,on_stem] = inpolygon(x,y,xv_stem,yv_stem);

% choice point
[in_cp,on_cp] = inpolygon(x,y,xv_cp,yv_cp);

% left reward field 
[in_lr,on_lr] = inpolygon(x,y,xv_lr,yv_lr);

% right reward field 
[in_rr,on_rr] = inpolygon(x,y,xv_rr,yv_rr);

% startbox 
[in_sb,on_sb] = inpolygon(x,y,xv_sb,yv_sb);

%% loop across data, identify entry and exit points and get timestamps

% intialize some variables
stem_entry     = [];
cp_entry       = []; % is stem exit
goalArm_entry  = []; % is choice point exit
goalZone_entry = []; % is goal arm exit
retArm_entry   = []; % is goal field exit
startBox_entry = []; % is return arm exit
trajectory     = [];

whereWasRat = [];


for triali = 1:size(Int,1)
    
    % Here, we will rewrite stem entry, cp exit, reward zone etc...
    idx = [];
    if triali == 1
        % get timestamps b4 startbox entry
        idx = find(t < Int(triali,8));
    elseif triali > 1
        % get timestamps bw past startbox and next startbox
        idx = find(t > Int(triali-1,8) & t < Int(triali,8));
    end
    
    % get position data within the index
    x_temp = []; y_temp = []; t_temp = [];
    x_temp = x(idx);
    y_temp = y(idx);
    t_temp = t(idx);
    
    % now define stem entry
    stem_temp = []; sb_temp = []; cp_temp = [];
    stem_temp = in_stem(idx);
    sb_temp   = in_sb(idx);
    
    % loop across stem variable, identify when theyre in stem
    idxKeep = [];
    for i = 1:length(stem_temp)
        if stem_temp(i) == 1 && sb_temp(i) == 0
            % store the point to keep
            idxKeep = i;
            % break out of the for loop
            break;
        end
    end
    
    % get the timestamp
    tKeep = [];
    tKeep = t_temp(idxKeep);
    
    % store timestamp
    Int(triali,1) = tKeep;
    
    % remove all timestamps up until this point
    t_temp(1:idxKeep)=[];
    x_temp(1:idxKeep)=[];
    y_temp(1:idxKeep)=[];
    idx(1:idxKeep) =[];
    
    % now identify cp exit
    cp_temp = []; cpL_temp = []; cpR_temp = [];
    cp_temp   = in_cp(idx);  
    cpL_temp  = in_lr(idx); % L is 0
    cpR_temp  = in_rr(idx); % R is 1
    
    % loop across cp variable, identify when theyre in cp
    idxKeep = [];
    for i = 1:length(cp_temp)
        if Int(triali,3) == 0
            % if they're in left reward and outside of cp
            if cpL_temp(i) == 1 && cp_temp(i) == 0
                idxKeep = i;
                % break
                break;
            end
        elseif Int(triali,3) == 1
            % if they're in left reward and outside of cp
            if cpR_temp(i) == 1 && cp_temp(i) == 0
                idxKeep = i;
                % break
                break;
            end
        end
    end
    
    % get the timestamp
    tKeep = [];
    tKeep = t_temp(idxKeep);
    
    % update the exit point
    Int(triali,6) = tKeep;
    
    % remove all timestamps before this point
    t_temp(1:idxKeep)=[];
    x_temp(1:idxKeep)=[];
    y_temp(1:idxKeep)=[];
    idx(1:idxKeep) =[];
    
    % now handle the reward exit point
    
    % now identify cp exit
    cpL_temp = []; cpR_temp = [];
    cpL_temp  = in_lr(idx); % L is 0
    cpR_temp  = in_rr(idx); % R is 1
    
    % loop across cp variable, identify when theyre in cp
    idxKeep = [];
    for i = 1:length(cpL_temp)
        if Int(triali,3) == 0
            % if they're not in left reward, but they used to be inside
            % of it, they must be leaving the reward. Also make sure they 
            if cpL_temp(i) == 0 && cpL_temp(i-1) == 1 && cp_temp(i-1) =
                idxKeep = i;
                % break
                break;
            end
        elseif Int(triali,3) == 1
            % if they're not in left reward, but they used to be inside
            % of it, they must be leaving the reward
            if cpR_temp(i) == 0 && cpR_temp(i-1) == 1
                idxKeep = i;
                % break
                break;
            end
        end
    end
    
    % get the timestamp
    tKeep = [];
    tKeep = t_temp(idxKeep);
    
    % update the exit point
    Int(triali,7) = tKeep;
    
    % remove all timestamps before this point
    t_temp(1:idxKeep)=[];
    x_temp(1:idxKeep)=[];
    y_temp(1:idxKeep)=[];    
    idx(1:idxKeep) =[];
end

% check Int for timing-position accuracy
question = 'Would you like to confirm your int file is correct? [Y/N] ';
answer   = input(question,'s');

if contains(answer,'Y') | contains(answer,'y')
    [remData] = checkInt(Int,x,y,t);
    
    % add column 9 that tells the user to remove the trial
    Int(:,9)=remData;

    numtrials = size(Int,1);
    for i = 1:numtrials-1
        if Int(i,3) == 1 && Int(i+1,3) == 0 || Int(i,3) == 0 && Int(i+1,3) == 1
            Int(i+1,4) = 0;
        else
            Int(i+1,4) = 1;
        end
    end
    percentCorrect = (((numtrials/2)-(sum(Int(:,4))/2))/(numtrials/2))*100;

    % display progress
    C = [];
    C = strsplit(datafolder,'\');
    X = [];
    X = [C{end},' behavioral accuracy = ',num2str(percentCorrect),'%'];
    disp(X);

else
    disp('IT IS RECOMMENDED that you check your int file as missing data will be stored as a non-existing trial');
end

% save data
question = 'Are you satisfied with the Int file and ready to save? [Y/N] ';
answer   = input(question,'s');

if contains(answer,'Y') | contains(answer,'y')
    cd(datafolder);
    
    % have user define a name
    question    = 'Please enter an Int file name: ';
    IntFileName = input(question,'s');
    
    % save
    save(IntFileName,'Int_old','Int_new');
end


